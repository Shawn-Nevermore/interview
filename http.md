[toc]

# 网络层通信

- AJAX/Fetch/axios
- HTTP 1.0/2.0（双向通道的好处，什么时候用2.0，HTTPS）
- TCP（三次握手四次挥手）
- 缓存（DNS，强缓存 & 协商缓存）
- 跨域处理方案
- 性能优化

实战中，
- 登录注册的前后端处理机制
- 加密策略：encodeURI-Component，MD5等
- 存储方案：cookie，webStorage，session等
- 用户权限和登陆态的校验处理
- Token的校验处理

## Q：跨域的实现方案
跨域产生的原因：前后端分离
常见问题：你服务器是怎么部署的？（Linux + Nginx + Docker）

### JSONP
### iframe
window.name
document.domain
location.hash
post.message
### CORS跨域资源共享
客户端
登陆验证：第一次向服务器发请求，服务器告诉你成功了，会通过JWT算法生成一个TOKEN，把TOKEN直接给你，当客户端拿到TOKEN之后，可以存储到vuex/localstorage中。再一次发请求，我们需要在请求拦截器上把token都带上，`config.headers.Authorization = token`，即在请求头里带上Authorization字段。服务器再次接收到请求，再通过JWT算法进行校验，如果是之前给的token，说明是合法。这就保证了接口调用信息的安全性。

服务器端
Access-Control-Allow-Origin
### 基于http proxy实现跨域请求

### Nginx反向代理

## HTTP缓存头部对比
| 头部          | 优势和特点                                                                                                           | 劣势和问题                                                                                                                                                                                                                          |
| ------------- | -------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Expires       | 1、HTTP 1.0 产物，可以在HTTP 1.0和1.1中使用，简单易用。2、以时刻标识失效时间。                                       | 1、时间是由服务器发送的(UTC)，如果服务器时间和客户端时间存在不一致，可能会出现问题。2、存在版本问题，到期之前的修改客户端是不可知的。                                                                                               |
| Cache-Control | 1、HTTP 1.1 产物，以时间间隔标识失效时间，解决了Expires服务器和客户端相对时间的问题。2、比Expires多了很多选项设置。  | 1、HTTP 1.1 才有的内容，不适用于HTTP 1.0 。2、存在版本问题，到期之前的修改客户端是不可知的。                                                                                                                                        |
| Last-Modified | 1、不存在版本问题，每次请求都会去服务器进行校验。服务器对比最后修改时间如果相同则返回304，不同返回200以及资源内容。  | 1、只要资源修改，无论内容是否发生实质性的变化，都会将该资源返回客户端。例如周期性重写，这种情况下该资源包含的数据实际上一样的。2、以时刻作为标识，无法识别一秒内进行多次修改的情况。3、某些服务器不能精确的得到文件的最后修改时间。 |
| ETag          | 1、可以更加精确的判断资源是否被修改，可以识别一秒内多次修改的情况。2、不存在版本问题，每次请求都回去服务器进行校验。 | 1、计算ETag值需要性能损耗。2、分布式服务器存储的情况下，计算ETag的算法如果不一样，会导致浏览器从一台服务器上获得页面内容后到另外一台服务器上进行验证时发现ETag不匹配的情况。                                                        |


